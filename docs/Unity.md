---
layout: default
title: Unity Interview Questions
parent: Basic Questions
nav_order: 2
---

# Unity Interview Questions
{: .no_toc }


## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

---

## Camera projection
1. Perspective projection
2. Orthographic projection

---

## Light
1. Directional light (sun)
2. Point light (bulb)
3. Spot light
4. Area light (Not supported in URP)

---

## What's a REST API
It's a way to send and receive information formatted as JSON to a server using HTTP requests.

---

## Difference between Update and FixedUpdate
Update runs once per frame. FixedUpdate run per fixed time, depending on how many physics frames per second are set in the time settings, and how fast/slow the framerate is.
It's for this reason that FixedUpdate should be used when applying forces, torques, or other physics-related functions - because you know it will be executed exactly in sync with the physics engine itself. Whereas Update() can vary out of step with the physics engine, either faster or slower, depending on how much of a load the graphics are putting on the rendering engine at any given time.

---

## What's design pattern
A design pattern is a general reusable solution to a commonly occurring problem within a given context in software design. It is a template or blueprint for solving a particular design problem in a way that is both effective and efficient. Design patterns can speed up the development process by providing tested, proven development paradigms.
In the context of game development with Unity, there are several commonly used design patterns. Here are a few examples: Singleton Pattern, Observer Pattern, Factory Method Pattern, Command Pattern, State Pattern, Decorator Pattern, Strategy Pattern, Component Pattern

---

## How does the GPU work

In short, the GPU graphics (processing) pipeline completes the following work:

- Vertex processing: At this stage, the GPU reads the vertex data describing the appearance of the 3D graphics and determines the shape and positional relationship of the 3D graphics based on the vertex data, establishing the skeleton of the 3D graphics. On GPUs that support the DX8 and DX9 specifications, these tasks are completed by the hardware-implemented Vertex Shader (fixed-point shader).
- Rasterization calculation: The image actually displayed on the monitor is composed of pixels. We need to convert the points and lines on the graphics generated above into the corresponding pixels through a certain algorithm. The process of converting a vector graphic into a series of pixels is called rasterization. For example, a mathematical representation of a diagonal line segment is eventually converted into a staircase-like continuous pixel point.
- Texture mapping: The polygons generated by the vertex unit only constitute the outline of the 3D object, while texture mapping completes the mapping of multi-deformed surfaces. In layman's terms, it means pasting the corresponding pictures on the polygonal surface, thereby Generate "realistic" graphics. TMU (Texture mapping unit) is used to complete this work.
- Pixel processing: In this stage (during the rasterization of each pixel) the GPU completes the calculations and processing of the pixels to determine the final properties of each pixel. In GPUs that support the DX8 and DX9 specifications, these tasks are completed by the hardware-implemented Pixel Shader.
- Final output: The ROP (rasterisation engine) finally completes the output of pixels. After one frame is rendered, it is sent to the video memory frame buffer.
- Summary: Generally speaking, the work of the GPU is to complete the generation of 3D graphics, map the graphics to the corresponding pixels, calculate each pixel to determine the final color and complete the output.

---

## The calculation formula for diffuse in lighting

{: .note }
diffuse = Kd x colorLight x max(N*L,0)

Kd is the diffuse reflection coefficient, colorLight is the color of the light, N is the unit normal vector, L is the unit vector pointing from the point to the light source, where N is the dot multiplied by L, if the result is less than or equal to 0, the diffuse reflection is 0.

---

## Performance

1. What's draw call? 
It's a call to the graphic API processed by the CPU telling the graphic card to draw something.

2. How to identify a CPU bottleneck? 
The profiling shows that the CPU tasks take more time to process than the GPU tasks.

3. How to solve a CPU bottleneck? 
Reducing the number of draw calls by merging objects, marking them static or using less materials.

4. How to optimize GPU usage of a scene?
- Reduce the polycount and/or the number of objects on screen.
- Reduce the number of dynamic lights.
- Reduce the number of lights casting shadows.
- Reduce the quality of the shadows and/or change the shadow technique.
- Bake everything that can be.
- Deactivate certain effects (bloom, depth of field...)